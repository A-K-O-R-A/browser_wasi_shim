<meta charset="utf-8">
<script type="module">
    import * as wasi from "./wasi_defs.js";
    import Fd from "./fd.js";

    class File {
        constructor(data) {
            console.log(data);
            this.data = new Uint8Array(data);
        }

        get size() {
            return this.data.byteLength;
        }

        open() {
            return new OpenFile(this);
        }

        stat() {
            return new wasi.Filestat(this.file_type, this.size);
        }

        truncate() {
            this.data = new Uint8Array([]);
        }
    }

    class OpenFile extends Fd {
        file_type = wasi.FILETYPE_REGULAR_FILE;

        constructor(file) {
            super();
            this.file = file;
            this.file_pos = 0;
        }

        get size() {
            return this.file.size;
        }

        read(len) {
            if (this.file_pos < this.file.data.byteLength) {
                let slice = this.file.data.slice(this.file_pos, this.file_pos + len);
                this.file_pos += slice.length;
                return [slice, 0];
            } else {
                return [[], 0];
            }
        }

        fd_read(view8, iovs) {
            let nread = 0;
            for (let iovec of iovs) {
                let [data, err] = this.read(iovec.buf_len);
                if (err != 0) {
                    return { ret: err, nread };
                }
                view8.set(data, iovec.buf);
                nread += data.length;
            }
            return { ret: 0, nread };
        }

        write(buffer) {
            console.log(this.file.data, this.file_pos, buffer.byteLength);
            if (this.file_pos + buffer.byteLength > this.size) {
                let old = this.file.data;
                this.file.data = new Uint8Array(this.file_pos + buffer.byteLength);
                this.file.data.set(old);
            }
            this.file.data.set(
                buffer.slice(
                    0,
                    this.size - this.file_pos,
                ), this.file_pos
            );
            this.file_pos += buffer.byteLength;
            return 0;
        }

        fd_write(view8, iovs) {
            let nwritten = 0;
            for (let iovec of iovs) {
                console.log(iovec.buf_len, iovec.buf_len, view8.slice(iovec.buf, iovec.buf + iovec.buf_len));
                let err = this.write(view8.slice(iovec.buf, iovec.buf + iovec.buf_len));
                if (err != 0) {
                    return { ret: err, nwritten };
                }
                nwritten += iovec.buf_len;
            }
            return { ret: 0, nwritten };
        }

        fd_filestat_get() {
            return { ret: 0, stat: this.file.stat() };
        }
    }

    class Directory extends Fd {
        file_type = wasi.FILETYPE_DIRECTORY;

        constructor(contents) {
            super();
            this.directory = contents;
        }

        fd_readdir_single(cookie) {
            console.log(cookie, Object.keys(this.directory).slice(Number(cookie)));
            if (cookie >= BigInt(Object.keys(this.directory).length)) {
                return { ret: 0, dirent: null };
            }

            let name = Object.keys(this.directory)[Number(cookie)];
            let entry = this.directory[name];
            let encoded_name = new TextEncoder("utf-8").encode(name);

            return { ret: 0, dirent: new wasi.Dirent(cookie + 1n, name, entry.file_type) };
        }

        path_filestat_get(flags, path) {
            let entry = this.get_entry_for_path(path);
            if (entry == null) {
                return { ret: -1, filestat: null };
            }
            return { ret: 0, filestat: entry.stat() };
        }

        path_open(dirflags, path, oflags, fs_rights_base, fs_rights_inheriting, fd_flags) {
            let entry = this.get_entry_for_path(path);
            if (entry == null) {
                if (oflags & wasi.OFLAGS_CREAT == wasi.OFLAGS_CREAT) {
                    entry = this.create_entry_for_path(path);
                } else {
                    return { ret: -1, fd_obj: null };
                }
            } else if (oflags & wasi.OFLAGS_EXCL == wasi.OFLAGS_EXCL) {
                return { ret: -1, fd_obj: null };
            }
            if (oflags & wasi.OFLAGS_DIRECTORY == wasi.OFLAGS_DIRECTORY && entry.file_type != wasi.FILETYPE_DIRECTORY) {
                return { ret: -1, fd_obj: null };
            }
            if (oflags & wasi.OFLAGS_TRUNC == wasi.OFLAGS_TRUNC) {
                entry.truncate();
            }
            return { ret: 0, fd_obj: entry.open() };
        }

        open() {
            return this;
        }

        get_entry_for_path(path) {
            let entry = this;
            for (let component of path.split("/")) {
                if (component == "") break;
                if (entry.directory[component] != undefined) {
                    entry = entry.directory[component];
                } else {
                    console.log(component);
                    return null;
                }
            }
            return entry;
        }

        create_entry_for_path(path) {
            let entry = this;
            let components = path.split("/").filter((component) => component != "/");
            for (let i in components) {
                let component = components[i];
                if (entry.directory[component] != undefined) {
                    entry = entry.directory[component];
                } else {
                    console.log("create", component);
                    if (i == components.length - 1) {
                        entry.directory[component] = new File(new ArrayBuffer(0));
                    } else {
                        entry.directory[component] = new Directory({});
                    }
                    entry = entry.directory[component];
                }
            }
            return entry;
        }

        stat() {
            return new wasi.Filestat(wasi.FILETYPE_DIRECTORY, 0);
        }
    }

    class PreopenDirectory extends Directory {
        constructor(name, contents) {
            super(contents);
            this.prestat_name = new TextEncoder("utf-8").encode(name);
        }

        fd_prestat_get() {
            return {
                ret: 0, prestat: wasi.Prestat.dir(this.prestat_name.length)
            };
        }

        fd_prestat_dir_name() {
            return {
                ret: 0, prestat_dir_name: this.prestat_name
            };
        }
    }

    class Stdio extends Fd {
        file_type = wasi.FILETYPE_UNKNOWN;

        read(len) {
            throw "unimplemented read from stdio";
        }

        write(buffer) {
            document.body.innerText += new TextDecoder("utf-8").decode(buffer);
            return 0;
        }

        fd_write(view8, iovs) {
            let nwritten = 0;
            for (let iovec of iovs) {
                console.log(iovec.buf_len, iovec.buf_len, view8.slice(iovec.buf, iovec.buf + iovec.buf_len));
                let err = this.write(view8.slice(iovec.buf, iovec.buf + iovec.buf_len));
                if (err != 0) {
                    return { ret: err, nwritten };
                }
                nwritten += iovec.buf_len;
            }
            return { ret: 0, nwritten };
        }
    }

    (async function () {
        document.body.style.fontFamily = "monospace";
        document.body.style.whiteSpace = "pre";
        document.body.innerText = "Downloading";
        let wasm = await WebAssembly.compileStreaming(fetch("rustc_binary.wasm"));
        //let wasm = await WebAssembly.compileStreaming(fetch("/rust_out.wasm"));
        document.body.innerText = "Instantiating";

        async function load_external_file(path) {
            return new File(await (await (await fetch(path)).blob()).arrayBuffer());
        }

        let args = ["rustc", "./hello.rs", "--sysroot", "/sysroot", "--target", "x86_64-unknown-linux-gnu", "-Cpanic=abort", "-Ccodegen-units=1"];
        let env = ["RUSTC_LOG=trace"];
        let fds = [
            new Stdio(),
            new Stdio(),
            new Stdio(),
            new PreopenDirectory("/tmp", {}),
            new PreopenDirectory(".", {
                "hello.rs": new File(new TextEncoder("utf-8").encode(`fn main() { println!("Hello World!"); }`)),
            }),
            new PreopenDirectory("/sysroot", {
                "lib": new Directory({
                    "rustlib": new Directory({
                        "wasm32-wasi": new Directory({
                            "lib": new Directory({}),
                        }),
                        "x86_64-unknown-linux-gnu": new Directory({
                            "lib": new Directory(await (async function () {
                                let dir = {};
                                for (let file of [
                                    "libcore-b4a7d25c83ac0d14.rlib",
                                    "librustc_std_workspace_core-18038143f92ab7ad.rlib",
                                    "libcompiler_builtins-f0b22b2b55b20afb.rlib",
                                    "liballoc-072489b01506fb72.rlib",
                                    "librustc_std_workspace_alloc-eeb0fd7b28eabbfd.rlib",
                                    "liblibc-f3a5d2870a74e12d.rlib",
                                    "libunwind-d85e8e3df3b56ff5.rlib",
                                    "libcfg_if-6b32ca81b3ffdff5.rlib",
                                    "libbacktrace_sys-93675d780e5d0925.rlib",
                                    "libbacktrace-30a7c0899d033fc0.rlib",
                                    "librustc_demangle-92b41332709a8741.rlib",
                                    "libhashbrown-f92f11aad8210abe.rlib",
                                    "libstd-358912be09271fe6.rlib",
                                    "libpanic_abort-9fa38857c2678ded.rlib",
                                ]) {
                                    dir[file] = await load_external_file("/sysroot/lib/rustlib/x86_64-unknown-linux-gnu/lib/" + file);
                                }
                                return dir;
                            })()),
                        }),
                    }),
                }),
            }),
        ];
        window.fds = fds;

        let inst = await WebAssembly.instantiate(wasm, {
            "wasi_snapshot_preview1": {
                args_sizes_get(argc, argv_buf_size) {
                    let buffer = new DataView(inst.exports.memory.buffer);
                    console.log("args_sizes_get(", argc, ", ", argv_buf_size, ")");
                    buffer.setUint32(argc, args.length, true);
                    let buf_size = 0;
                    for (let arg of args) {
                        buf_size += arg.length + 1;
                    }
                    buffer.setUint32(argv_buf_size, buf_size, true);
                    console.log(buffer.getUint32(argc, true), buffer.getUint32(argv_buf_size, true));
                    return 0;
                },
                args_get(argv, argv_buf) {
                    let buffer = new DataView(inst.exports.memory.buffer);
                    let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                    console.log("args_get(", argv, ", ", argv_buf, ")");
                    let orig_argv_buf = argv_buf;
                    for (let i = 0; i < args.length; i++) {
                        buffer.setUint32(argv, argv_buf, true);
                        argv += 4;
                        let arg = new TextEncoder("utf-8").encode(args[i]);
                        buffer8.set(arg, argv_buf);
                        buffer.setUint8(argv_buf + arg.length, 0);
                        argv_buf += arg.length + 1;
                    }
                    console.log(new TextDecoder("utf-8").decode(buffer8.slice(orig_argv_buf, argv_buf)));
                    return 0;
                },

                environ_sizes_get(environ_count, environ_size) {
                    let buffer = new DataView(inst.exports.memory.buffer);
                    console.log("environ_sizes_get(", environ_count, ", ", environ_size, ")");
                    buffer.setUint32(environ_count, env.length, true);
                    let buf_size = 0;
                    for (let environ of env) {
                        buf_size += environ.length + 1;
                    }
                    buffer.setUint32(environ_size, buf_size, true);
                    console.log(buffer.getUint32(environ_count, true), buffer.getUint32(environ_size, true));
                    return 0;
                },
                environ_get(environ, environ_buf) {
                    let buffer = new DataView(inst.exports.memory.buffer);
                    let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                    console.log("environ_get(", environ, ", ", environ_buf, ")");
                    let orig_environ_buf = environ_buf;
                    for (let i = 0; i < env.length; i++) {
                        buffer.setUint32(environ, environ_buf, true);
                        environ += 4;
                        let e = new TextEncoder("utf-8").encode(env[i]);
                        buffer8.set(e, environ_buf);
                        buffer.setUint8(environ_buf + e.length, 0);
                        environ_buf += e.length + 1;
                    }
                    console.log(new TextDecoder("utf-8").decode(buffer8.slice(orig_environ_buf, environ_buf)));
                    return 0;
                },

                clock_res_get(id, res_ptr) {
                    throw "unimplemented";
                },
                clock_time_get(id, precision, time) {
                    let buffer = new DataView(inst.exports.memory.buffer);
                    //console.log("clock_time_get(", id, ", ", precision, ", ", time, ")");
                    buffer.setBigUint64(time, 0n, true);
                    return 0;
                },

                fd_advise(fd, offset, len, advice) {
                    if (fds[fd] != undefined) {
                        return fds[fd].fd_advise(offset, len, advice);
                    } else {
                        return -1;
                    }
                },
                fd_allocate(fd, offset, len) {
                    if (fds[fd] != undefined) {
                        return fds[fd].fd_allocate(offset, len);
                    } else {
                        return -1;
                    }
                },
                fd_close(fd) {
                    if (fds[fd] != undefined) {
                        let ret = fds[fd].fd_close();
                        fds[fd] = undefined;
                        return ret;
                    } else {
                        return -1;
                    }
                },
                fd_datasync(fd) {
                    if (fds[fd] != undefined) {
                        return fds[fd].fd_datasync();
                    } else {
                        return -1;
                    }
                },
                fd_fdstat_get(fd, fdstat_ptr) {
                    if (fds[fd] != undefined) {
                        let { ret, fdstat } = fds[fd].fd_fdstat_get();
                        if (fdstat != null) {
                            fdstat.write_bytes(new DataView(inst.exports.memory.buffer), fdstat_ptr);
                        }
                        return ret;
                    } else {
                        return -1;
                    }
                },
                fd_fdstat_set_flags(fd, flags) {
                    if (fds[fd] != undefined) {
                        return fds[fd].fd_fdstat_set_flags(flags);
                    } else {
                        return -1;
                    }
                },
                fd_fdstat_set_rights(fd, rights) {
                    if (fds[fd] != undefined) {
                        return fds[fd].fd_fdstat_set_rights(rights);
                    } else {
                        return -1;
                    }
                },
                fd_filestat_get(fd, filestat_ptr) {
                    if (fds[fd] != undefined) {
                        let { ret, filestat } = fds[fd].fd_filestat_get();
                        if (filestat != null) {
                            filestat.write_bytes(new DataView(inst.exports.memory.buffer), filestat_ptr);
                        }
                        return ret;
                    } else {
                        return -1;
                    }
                },
                fd_filestat_set_size(fd, size) {
                    if (fds[fd] != undefined) {
                        return fds[fd].fd_filestat_set_size(size);
                    } else {
                        return -1;
                    }
                },
                fd_filestat_set_times(fd, atim, mtim, fst_flags) {
                    if (fds[fd] != undefined) {
                        return fds[fd].fd_filestat_set_times(atim, mtim, fst_flags);
                    } else {
                        return -1;
                    }
                },
                fd_pread(fd, iovs_ptr, iovs_len, offset, nread_ptr) {
                    let buffer = new DataView(inst.exports.memory.buffer);
                    let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                    if (fds[fd] != undefined) {
                        let iovecs = wasi.Iovec.read_bytes_array(buffer, iovs_ptr, iovs_len);
                        let { ret, nread } = fds[fd].fd_pread(buffer8, iovecs, offset);
                        buffer.setUint32(nread_ptr, nread, true);
                        return ret;
                    } else {
                        return -1;
                    }
                },
                fd_prestat_get(fd, buf_ptr) {
                    let buffer = new DataView(inst.exports.memory.buffer);
                    console.log("fd_prestat_get(", fd, ", ", buf_ptr, ")");
                    if (fds[fd] != undefined) {
                        let { ret, prestat } = fds[fd].fd_prestat_get();
                        if (prestat != null) {
                            prestat.write_bytes(buffer, buf_ptr);
                        }
                        return ret;
                    } else {
                        return -1;
                    }
                },
                fd_prestat_dir_name(fd, path_ptr, path_len) {
                    // FIXME don't ignore path_len
                    console.log("fd_prestat_dir_name(", fd, ", ", path_ptr, ", ", path_len, ")");
                    if (fds[fd] != undefined && fds[fd].prestat_name != undefined) {
                        let { ret, prestat_dir_name } = fds[fd].fd_prestat_dir_name();
                        if (prestat_dir_name != null) {
                            let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                            buffer8.set(prestat_dir_name, path_ptr);
                        }
                        return ret;
                    } else {
                        return -1;
                    }
                },
                fd_pwrite(fd, iovs_ptr, iovs_len, offset, nwritten_ptr) {
                    let buffer = new DataView(inst.exports.memory.buffer);
                    let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                    if (fds[fd] != undefined) {
                        let iovecs = wasi.Ciovec.read_bytes_array(buffer, iovs_ptr, iovs_len);
                        let { ret, nwritten } = fds[fd].fd_pwrite(buffer8, iovecs, offsets);
                        buffer.setUint32(nwritten_ptr, nwritten, true);
                        return ret;
                    } else {
                        return -1;
                    }
                },
                fd_read(fd, iovs_ptr, iovs_len, nread_ptr) {
                    let buffer = new DataView(inst.exports.memory.buffer);
                    let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                    if (fds[fd] != undefined) {
                        let iovecs = wasi.Iovec.read_bytes_array(buffer, iovs_ptr, iovs_len);
                        let { ret, nread } = fds[fd].fd_read(buffer8, iovecs);
                        buffer.setUint32(nread_ptr, nread, true);
                        return ret;
                    } else {
                        return -1;
                    }
                },
                fd_readdir(fd, buf, buf_len, cookie, bufused_ptr) {
                    let buffer = new DataView(inst.exports.memory.buffer);
                    let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                    if (fds[fd] != undefined && fds[fd].directory != undefined) {
                        let bufused = 0;

                        while (true) {
                            let { ret, dirent } = fds[fd].fd_readdir_single(cookie);
                            if (ret != 0) {
                                buffer.setUint32(bufused_ptr, bufused, true);
                                return ret;
                            }
                            if (dirent == null) {
                                break;
                            }
                            let offset = dirent.length();

                            if ((buf_len - bufused) < offset) {
                                break;
                            }

                            dirent.write_bytes(buffer, buffer8, buf);
                            buf += offset;
                            bufused += offset;
                            cookie = dirent.d_next;
                        }

                        buffer.setUint32(bufused_ptr, bufused, true);
                        return 0;
                    } else {
                        return -1;
                    }
                },
                fd_renumber(fd, to) {
                    if (fds[fd] != undefined && fds[to] != undefined) {
                        let ret = fds[to].fd_close()
                        if (ret != 0) {
                            return ret;
                        }
                        fds[to] = fds[fd];
                        fds[fd] = undefined;
                        return 0;
                    } else {
                        return -1;
                    }
                },
                fd_seek(fd, offset, whence, offset_out_ptr) {
                    if (fds[fd] != undefined) {
                        let { ret, offset } = fds[fd].fd_seek(offset, whence);
                        buffer.setUint32(offset_out_ptr, offset_out, true);
                    } else {
                        return -1;
                    }
                },
                fd_sync(fd) {
                    if (fds[fd] != undefined) {
                        return fds[fd].fd_sync();
                    } else {
                        return -1;
                    }
                },
                fd_tell(fd, offset_ptr) {
                    if (fds[fd] != undefined) {
                        let { ret, offset } = fds[fd].fd_tell();
                        buffer.setUint32(offset_ptr, offset, true);
                    } else {
                        return -1;
                    }
                },
                fd_write(fd, iovs_ptr, iovs_len, nwritten_ptr) {
                    let buffer = new DataView(inst.exports.memory.buffer);
                    let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                    if (fds[fd] != undefined) {
                        let iovecs = wasi.Ciovec.read_bytes_array(buffer, iovs_ptr, iovs_len);
                        let { ret, nwritten } = fds[fd].fd_write(buffer8, iovecs);
                        buffer.setUint32(nwritten_ptr, nwritten, true);
                        return ret;
                    } else {
                        return -1;
                    }
                },
                path_create_directory(fd, path_ptr, path_len) {
                    let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                    if (fds[fd] != undefined) {
                        let path = new TextDecoder("utf-8").decode(buffer8.slice(path_ptr, path_ptr + path_len));
                        return fds[fd].path_create_directory(path);
                    }
                },
                path_filestat_get(fd, flags, path_ptr, path_len, filestat_ptr) {
                    let buffer = new DataView(inst.exports.memory.buffer);
                    let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                    if (fds[fd] != undefined) {
                        let path = new TextDecoder("utf-8").decode(buffer8.slice(path_ptr, path_ptr + path_len));
                        let { ret, filestat } = fds[fd].path_filestat_get(flags, path);
                        if (filestat != null) {
                            filestat.write_bytes(buffer, filestat_ptr);
                        }
                        return ret;
                    } else {
                        return -1;
                    }
                },
                path_filestat_set_times(fd, flags, path_ptr, path_len, atim, mtim, fst_flags) {
                    let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                    if (fds[fd] != undefined) {
                        let path = new TextDecoder("utf-8").decode(buffer8.slice(path_ptr, path_ptr + path_len));
                        return fds[fd].path_filestat_set_times(flags, path, atim, mtim, fst_flags);
                    } else {
                        return -1;
                    }
                },
                path_link(old_fd, old_flags, old_path_ptr, old_path_len, new_fd, new_path_ptr, new_path_len) {
                    let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                    if (fds[old_fd] != undefined && fds[new_fs] != undefined) {
                        let old_path = new TextDecoder("utf-8").decode(buffer8.slice(old_path_ptr, old_path_ptr + old_path_len));
                        let new_path = new TextDecoder("utf-8").decode(buffer8.slice(new_path_ptr, new_path_ptr + new_path_len));
                        return fds[new_fd].path_link(old_fd, old_flags, old_path, new_path);
                    } else {
                        return -1;
                    }
                },
                path_open(fd, dirflags, path_ptr, path_len, oflags, fs_rights_base, fs_rights_inheriting, fd_flags, opened_fd_ptr) {
                    let buffer = new DataView(inst.exports.memory.buffer);
                    let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                    if (fds[fd] != undefined) {
                        let path = new TextDecoder("utf-8").decode(buffer8.slice(path_ptr, path_ptr + path_len));
                        console.log(path);
                        let { ret, fd_obj } = fds[fd].path_open(dirflags, path, oflags, fs_rights_base, fs_rights_inheriting, fd_flags);
                        if (ret != 0) {
                            return ret;
                        }
                        // FIXME use first free fd
                        fds.push(fd_obj);
                        let opened_fd = fds.length - 1;
                        buffer.setUint32(opened_fd_ptr, opened_fd, true);
                        return 0;
                    } else {
                        return -1;
                    }
                },
                path_readlink(fd, path_ptr, path_len, buf_ptr, buf_len, nread_ptr) {
                    let buffer = new DataView(inst.exports.memory.buffer);
                    let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                    if (fds[fd] != undefined) {
                        let path = new TextDecoder("utf-8").decode(buffer8.slice(path_ptr, path_ptr + path_len));
                        console.log(path);
                        let { ret, data } = fds[fd].path_readlink(path);
                        if (data != null) {
                            if (data.length > buf_len) {
                                buffer.setUint32(nread_ptr, 0, true);
                                return -1;
                            }
                            buffer8.set(data, buf_ptr);
                            buffer.setUint32(nread_ptr, data.length, true);
                        }
                        return ret;
                    } else {
                        return -1;
                    }
                },
                path_remove_directory(fd, path_ptr, path_len) {
                    let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                    if (fds[fd] != undefined) {
                        let path = new TextDecoder("utf-8").decode(buffer8.slice(path_ptr, path_ptr + path_len));
                        return fds[fd].path_remove_directory(path);
                    } else {
                        return -1;
                    }
                },
                path_rename(fd, old_path_ptr, old_path_len, new_fd, new_path_ptr, new_path_len) {
                    throw "FIXME what is the best abstraction for this?";
                },
                path_symlink(old_path_ptr, old_path_len, fd, new_path_ptr, new_path_len) {
                    let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                    if (fds[fd] != undefined) {
                        let old_path = new TextDecoder("utf-8").decode(buffer8.slice(old_path_ptr, old_path_ptr + old_path_len));
                        let new_path = new TextDecoder("utf-8").decode(buffer8.slice(new_path_ptr, new_path_ptr + new_path_len));
                        return fds[new_fd].path_symlink(old_path, new_path);
                    } else {
                        return -1;
                    }
                },
                path_unlink_file(fd, path_ptr, path_len) {
                    let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                    if (fds[fd] != undefined) {
                        let path = new TextDecoder("utf-8").decode(buffer8.slice(path_ptr, path_ptr + path_len));
                        return fds[fd].path_unlink_file(path);
                    } else {
                        return -1;
                    }
                },
                poll_oneoff(in_, out, nsubscriptions) {
                    throw "async io not supported";
                },
                proc_exit(exit_code) {
                    throw "exit with exit code " + exit_code;
                },
                proc_raise(sig) {
                    throw "raised signal " + sig;
                },
                sched_yield() {},
                random_get(buf, buf_len) {
                    let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                    for (let i = 0; i < buf_len; i++) {
                        buffer8[buf + i] = (Math.random() * 256) | 0;
                    }
                },
                sock_recv(fd, ri_data, ri_flags) {
                    throw "sockets not supported";
                },
                sock_send(fd, si_data, si_flags) {
                    throw "sockets not supported";
                },
                sock_shutdown(fd, how) {
                    throw "sockets not supported";
                }
            }
        });
        document.body.innerText = "Executing\n";
        console.log(inst.exports);
        try { inst.exports._start(); } catch (e) { }
        try { inst.exports.main(); } catch (e) { console.error(e); }
        document.body.innerText += "\nDone";

        console.log(fds[4].directory);
        console.log(fds[4].directory["hello.hello.7rcbfp3g-cgu.0.rcgu.o"].data);
        document.body.innerHTML += "<br><a href='" + URL.createObjectURL(new Blob([fds[4].directory["hello.hello.7rcbfp3g-cgu.0.rcgu.o"].data], { type: "application/elf" })) + "'>Download object</a>";
        document.body.innerHTML += "<br><a href='" + URL.createObjectURL(new Blob([fds[4].directory["hello.allocator_shim.rcgu.o"].data], { type: "application/elf" })) + "'>Download allocator shim</a>";
    })();
</script>
